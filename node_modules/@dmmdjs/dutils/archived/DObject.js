"use strict";

// Variables
let areEntries = v => {
    if(!Array.isArray(v)) return false;
    return v.every(e => Array.isArray(e) && e.length >= 2);
};

/**
 * Advanced prototype of JavaScript object
 */
class DObject {
    #f = {
        locked: false,
        useStrict: false
    };
    #m = new Map();
    #p;

    /**
     * Creates a new dobject
     * @param {boolean} s Whether or not to use strict
     */
    constructor(s) {
        if(s) this.useStrict();
        this.#p = new Proxy({ instance: this }, {
            defineProperty(t, k, d) {
                return t.instance.setDescriptor(k, d);
            },
            deleteProperty(t, k) {
                return t.instance.delete(k);
            },
            get: (t, k) => {
                if(k in t.instance.constructor.prototype) {
                    let p = t.instance[k];
                    return typeof p === "function" ? p.bind(t.instance) : p;
                };
                return t.instance.get(k);
            },
            getOwnPropertyDescriptor(t, k) {
                return t.instance.getDescriptor(k);
            },
            getPrototypeOf(t) {
                return t.instance;
            },
            has(t, k) {
                return t.instance.has(k);
            },
            isExtensible(t) {
                return t.instance.flags.locked;
            },
            ownKeys(t) {
                return t.instance.keys;
            },
            preventExtensions(t) {
                return t.instance.lock();
            },
            set(t, k, v) {
                return t.instance.set(k, v);
            },
            setPrototypeOf() {
                throw new Error("Please do not modify this instance");
            }
        });
        return this.#p;
    };

    /**
     * Clears this dobject
     * @returns {boolean}
     */
    clear() {
        if(this.#f.locked) {
            if(this.#f.useStrict) throw new Error("This instance is locked");
            return true;
        };
        return this.delete(...this.keys);
    };

    /**
     * Deletes keys from this dobject
     * @param {any} ks Keys
     * @returns {boolean}
     */
    delete(...ks) {
        if(this.#f.locked) {
            if(this.#f.useStrict) throw new Error("This instance is locked");
            return true;
        };
        for(let k of ks) {
            if(!this.has(k)) continue;
            if(this.getDescriptor(k)?.configurable === false) {
                if(this.#f.useStrict) throw new Error(`Key ${k} is not configurable`);
                continue;
            };
            this.#m.delete(k);
        };
        return true;
    };

    /**
     * Returns the entries of this dobject
     * @readonly
     * @returns {[ any, any ][]}
     */
    get entries() {
        return this.getDescriptors().filter(d => d[1]?.enumerable !== false).map(d => [ d[0], this.get(d[0]) ]);
    };

    /**
     * Returns if all values pass the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {boolean}
     */
    every(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let es = this.entries;
        for(let e of es) if(!!cb(e[1], e[0], e, es, this) !== true) return false;
        return true;
    };

    /**
     * Finds all values that pass the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {any[]}
     */
    filter(cb) {
        return this.filterEntries(cb).map(e => e[1]);
    };

    /**
     * Finds all entries that pass the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {[ any, any ][]}
     */
    filterEntries(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let es = this.entries, arr = [];
        for(let e of es) if(!!cb(e[1], e[0], e, es, this) === true) arr.push(e);
        return arr;
    };

    /**
     * Finds all keys that pass the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {any[]}
     */
    filterKeys(cb) {
        return this.filterEntries(cb).map(e => e[0]);
    };

    /**
     * Finds the first value that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {?any}
     */
    find(cb) {
        let e = this.findEntry(cb);
        return e ? e[1] : undefined;
    };

    /**
     * Finds the first entry that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {?[ any, any ]}
     */
    findEntry(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let es = this.entries;
        for(let e of es) if(!!cb(e[1], e[0], e, es, this) === true) return e;
        return undefined;
    };

    /**
     * Finds the first key that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {?any}
     */
    findKey(cb) {
        let e = this.findEntry(cb);
        return e ? e[0] : undefined;
    };

    /**
     * Finds the last value that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {?any}
     */
    findLast(cb) {
        let e = this.findLastEntry(cb);
        return e ? e[1] : undefined;
    };

    /**
     * Finds the last entry that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {?[ any, any ]}
     */
    findLastEntry(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let es = this.entries.reverse();
        for(let e of es) if(!!cb(e[1], e[0], e, es, this) === true) return e;
        return undefined;
    };

    /**
     * Finds the ;ast key that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {?any}
     */
    findLastKey(cb) {
        let e = this.findLastEntry(cb);
        return e ? e[0] : undefined;
    };

    /**
     * Gets the flags set in this dobject
     * @readonly
     * @returns {{
     *     locked: boolean
     *     useStrict: boolean
     * }}
     */
    get flags() {
        return { ...this.#f };
    };

    /**
     * Loops through each enumerable value
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {boolean}
     */
    forEach(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let es = this.entries;
        es.forEach(e => cb(e[1], e[0], e, this, es));
        return true;
    };

    /**
     * Creates a new dobject from an existing object
     * @static
     * @param {object} obj Object
     * @param {boolean} s Whether or not to use strict
     * @returns {DObject}
     */
    static from(obj, s) {
        if(typeof obj !== "object") throw new TypeError("Argument is not an object");
        let dobj = new DObject(s);
        let ds = Object.getOwnPropertyDescriptors(obj);
        for(let k in ds) dobj.setDescriptor(k, ds[k]);
        return dobj;
    };

    /**
     * Gets a value from this dobject
     * @param {any} k Key
     * @returns {?any}
     */
    get(k) {
        if(!this.has(k)) return undefined;
        let d = this.getDescriptor(k);
        return "get" in d ? d.get() : d.value;
    };

    /**
     * Gets a descriptor from this dobject
     * @param {any} k Key
     * @returns {?object}
     */
    getDescriptor(k) {
        if(!this.has(k)) return undefined;
        return this.#m.get(k);
    };

    /**
     * Gets all descriptors from this dobject
     * @returns {[ any, object ][]}
     */
    getDescriptors() {
        return Array.from(this.#m.entries());
    };

    /**
     * Returns whether or not the key exists in this dobject
     * @param {any} k Key
     * @returns {boolean}
     */
    has(k) {
        return this.#m.has(k);
    };

    /**
     * Returns the true instance of this dobject
     * @readonly
     * @returns {DObject}
     */
    get instance() {
        return this;
    };

    /**
     * Returns whether or not this dobject is locked
     * @readonly
     * @returns {boolean}
     */
    get isLocked() {
        return this.#f.locked;
    };

    /**
     * Returns whether or not this dobject is using strict mode
     * @readonly
     * @returns {boolean}
     */
    get isStrict() {
        return this.#f.useStrict;
    };

    /**
     * Returns the keys of this dobject
     * @readonly
     * @returns {any[]}
     */
    get keys() {
        return this.entries.map(e => e[0]);
    };

    /**
     * Locks this dobject and prevents further modifications
     * @returns {boolean}
     */
    lock() {
        if(this.#f.locked) {
            if(this.#f.useStrict) throw new Error("This instance is locked");
            return true;
        };
        this.#f.locked = true;
        return true;
    };

    /**
     * Maps through each enumerable value
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {DObject}
     */
    map(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let dobj = new DObject();
        this.forEach((v, k, e, es, ins) => {
            let d = this.getDescriptor(k);
            if("get" in d && "set" in d) dobj.setDescriptor(k, {
                get: () => cb(d.get(), k, e, es, ins),
                set: () => d.set()
            });
            else dobj.setDescriptor(k, {
                configurable: d.configurable,
                enumerable: d.enumerable,
                value: cb(v, k, e, es, ins),
                writable: d.writable
            });
        });
        return dobj;
    };

    /**
     * Merges enumerable keys and values from one or more dobjects to this dobject
     * @param {...dobject} dobjs DObjects
     * @returns {boolean}
     */
    merge(...dobjs) {
        if(this.#f.locked) {
            if(this.#f.useStrict) throw new Error("This instance is locked");
            return true;
        };
        for(let dobj of dobjs) {
            if(!(dobj instanceof DObject)) {
                if(dobj === null || dobj === undefined) continue;
                if(this.#f.useStrict) throw new TypeError("Argument is not an instance of DObject");
                continue;
            };
            if(Object.is(this, dobj.instance)) {
                if(this.#f.useStrict) throw new Error("Cannot merge with itself");
                continue;
            };
            this.setDescriptors(dobj.getDescriptors());
        };
        return true;
    };

    /**
     * Returns the true proxy of this dobject
     * @readonly
     * @returns {Proxy}
     */
    get proxy() {
        return this.#p;
    };

    /**
     * Sets a value with the associating key to this dobject
     * @param {any} k Key
     * @param {any} v Value
     * @returns {boolean}
     */
    set(k, v) {
        if(this.has(k)) {
            let d = this.getDescriptor(k);
            if("set" in d) {
                d.set(v);
                return true;
            }
            else if(d?.writable === false) {
                if(this.#f.useStrict) throw new Error(`Key ${k} is not writable`);
                return true;
            };
            return this.setDescriptor(k, {
                configurable: d.configurable,
                enumerable: d.enumerable,
                value: v,
                writable: d.writable
            });
        };
        return this.setDescriptor(k, {
            configurable: true,
            enumerable: true,
            value: v,
            writable: true
        });
    };

    /**
     * Sets a descriptor with the associating key to this dobject
     * @param {any} k Key
     * @param {object} d Descriptor
     * @returns {boolean}
     */
    setDescriptor(k, d) {
        if(this.#f.locked) {
            if(this.#f.useStrict) throw new Error("This instance is locked");
            return true;
        };
        if(this.has(k) && this.getDescriptor(k)?.configurable === false) {
            if(this.#f.useStrict) throw new Error(`Key ${k} is not configurable`);
            return true;
        };
        if("get" in d || "set" in d) {
            if([ d.get, d.set ].some(v => typeof v !== "function")) {
                if(this.#f.useStrict) throw new TypeError("Argument is not a function");
                return true;
            };
            this.#m.set(k, { get: d.get, set: d.set });
        }
        else this.#m.set(k, {
            configurable: d?.configurable === true,
            enumerable: d?.enumerable === true,
            value: d?.value,
            writable: d?.writable === true
        });
        return true;
    };

    /**
     * Sets multiple descriptors to this dobject
     * @param {[ any, object ][]} ds Descriptors
     * @returns {boolean}
     */
    setDescriptors(es) {
        if(!areEntries(es)) throw new Error("Argument are not entries");
        for(let e of es) this.setDescriptor(e[0], e[1]);
        return true;
    };

    /**
     * Sets a readonly value with the associating key to this dobject
     * @param {any} k Key
     * @param {any} v Value
     * @returns {boolean}
     */
    setReadOnly(k, v) {
        return this.setDescriptor(k, {
            configurable: false,
            enumerable: true,
            value: v,
            writable: false
        });
    };

    /**
     * Returns the size of this dobject
     * @readonly
     * @returns {number}
     */
    get size() {
        return this.entries.length;
    };

    /**
     * Returns if a value passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DObject)} cb Callback
     * @returns {boolean}
     */
    some(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let es = this.entries;
        for(let e of es) if(!!cb(e[1], e[0], e, es, this) === true) return true;
        return false;
    };

    /**
     * Returns this dobject as a JavaScript object
     * @returns {object}
     */
    toObject() {
        let obj = {};
        Object.defineProperties(obj, Object.fromEntries(this.getDescriptors()));
        return obj;
    };

    /**
     * Returns this dobject as a JavaScript string
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toObject());
    };

    /**
     * Enables strict mode in this dobject
     * @returns {boolean}
     */
    useStrict() {
        if(this.#f.locked) {
            if(this.#f.useStrict) throw new Error("This instance is locked");
            return true;
        };
        this.#f.useStrict = true;
        return true;
    };

    /**
     * Returns the values of this dobject
     * @readonly
     * @returns {any[]}
     */
    get values() {
        return this.entries.map(e => e[1]);
    };

    /**
     * Returns this darray as a JavaScript object
     * @returns {object}
     */
    valueOf() {
        return this.toObject();
    };
};

// Exports
module.exports = DObject;