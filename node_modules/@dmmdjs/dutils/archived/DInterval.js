"use strict";

// Imports
const Events = require("events");

/**
 * Consistent interval with accurate timing
 * @extends Events
 */
class DInterval extends Events {
    #k = false;
    #i(t) {
        let d = Date.now() - t;
        this.#it++; super.emit("iterate");
        if(!this.#k) setTimeout(() => this.#i.call(this, this.#t + t), Math.max(0, this.#t - d));
    };
    #it = 0;
    #t = 0;

    /**
     * Creates a new dinterval
     * @param {number} t Timeout in milliseconds
     */
    constructor(t) {
        super();
        this.setTimeout(t);
        this.#i.call(this, Date.now() + this.#t);
    };

    /**
     * Returns whether or not this dinterval has been killed
     * @readonly
     * @returns {boolean}
     */
    get isKilled() {
        return this.#k;
    };

    /**
     * Returns the total iterations of this dinterval
     * @readonly
     * @returns {number}
     */
    get iterations() {
        return this.#it;
    };

    /**
     * Kills this dinterval
     * @param {any} r Reason
     */
    kill(r) {
        if(this.#k) throw new Error("Interval is killed");
        super.emit("kill", r);
        this.#k = true;
    };

    /**
     * Sets a new timeout
     * @param {number} t Timeout in milliseconds
     */
    setTimeout(t) {
        if(this.#k) throw new Error("Interval is killed");
        if(isNaN(t)) throw new TypeError("Argument is not a number-like value");
        let pt = parseFloat(t);
        if(pt <= 0) throw new Error("Timeout is too short");
        this.#t = pt;
    };

    /**
     * Returns the current timeout of this dinterval
     * @readonly
     * @returns {number}
     */
    get timeout() {
        return this.#t;
    };
};

// Exports
module.exports = DInterval;