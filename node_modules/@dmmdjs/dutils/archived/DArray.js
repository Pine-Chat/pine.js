"use strict";

// Imports
const DObject = require("./DObject.js");

// Variables
let areEntries = v => {
    if(!Array.isArray(v)) return false;
    return v.every(e => Array.isArray(e) && e.length >= 2);
};
let isInt = (v, max = Infinity, min = 0) => {
    if(isNaN(v)) return false;
    let pv = parseFloat(v);
    if(!Number.isInteger(pv)) return false;
    return min <= pv && pv <= max;
};

/**
 * Advanced prototype of JavaScript array
 * @extends DObject
 */
class DArray extends DObject {
    #l = 0;

    /**
     * Creates a new darray
     * @param {number} length Length of darray
     * @param {boolean} s Whether or not to use strict
     */
    constructor(l, s) {
        super(s);
        if(isInt(l)) this.#l = l;
    };

    /**
     * Clears this darray
     * @returns {boolean}
     */
    clear() {
        return super.clear();
    };

    /**
     * Deletes keys from this darray
     * @param {any} ks Keys
     * @returns {boolean}
     */
    delete(...ks) {
        return super.delete(...ks.map(k => this.inRange(k) ? `${k}` : k));
    };

    /**
     * Returns the elements of this darray
     * @readonly
     * @returns {any[]}
     */
    get elements() {
        return this.pairs.map(p => p[1]);
    };

    /**
     * Returns the entries of this darray
     * @readonly
     * @returns {[ any, any ][]}
     */
    get entries() {
        return super.entries;
    };

    /**
     * Returns if all elements pass the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @returns {boolean}
     */
    every(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let i = 0; i < this.proxy.#l; i++) {
            if(!this.has(i)) continue;
            if(this.getDescriptor(i)?.enumerable === false) continue;
            let v = this.get(i);
            if(!!cb(v, i, [ i, v ], this.pairs, this) !== true) return false;
        };
        return true;
    };

    /**
     * Returns if all values pass the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {boolean}
     */
    everyValue(cb) {
        return super.every(cb);
    };

    /**
     * Fills the darray with the value
     * @param {any} v Value
     * @returns {boolean}
     */
    fill(v) {
        for(let i = 0; i < this.proxy.#l; i++) if(!this.has(i)) this.set(i, v);
        return true;
    };

    /**
     * Finds all elements that pass the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray )} cb Callback
     * @returns {any[]}
     */
    filter(cb) {
        return this.filterPairs(cb).map(p => p[1]);
    };

    /**
     * Finds all entries that pass the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {[ any, any ][]}
     */
    filterEntries(cb) {
        return super.filterEntries(cb);
    };

    /**
     * Finds all indexes that pass the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray )} cb Callback
     * @returns {number[]}
     */
    filterIndexes(cb) {
        return this.filterPairs(cb).map(p => p[0]);
    };

    /**
     * Finds all keys that pass the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {any[]}}
     */
    filterKeys(cb) {
        return super.filterKeys(cb);
    };

    /**
     * Finds all pairs that pass the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray )} cb Callback
     * @returns {[ number, any ][]}
     */
    filterPairs(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let arr = [];
        for(let i = 0; i < this.proxy.#l; i++) {
            if(!this.has(i)) continue;
            if(this.getDescriptor(i)?.enumerable === false) continue;
            let v = this.get(i);
            if(!!cb(v, i, [ v, i ], this.pairs, this) === true) arr.push([ v, i ]);
        };
        return arr;
    };

    /**
     * Finds all values that pass the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {?any}
     */
    filterValues(cb) {
        return super.filter(cb);
    };

    /**
     * Finds the first element that passes the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @returns {?any}
     */
    find(cb) {
        let p = this.findPair(cb);
        return p ? p[1] : undefined;
    };

    /**
     * Finds the first entry that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {?any}
     */
    findEntry(cb) {
        return super.findEntry(cb);
    };

    /**
     * Finds the first index that passes the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @returns {?any}
     */
    findIndex(cb) {
        let p = this.findPair(cb);
        return p ? p[0] : undefined;
    };

    /**
     * Finds the first key that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {?number}
     */
    findKey(cb) {
        return super.findKey(cb);
    };

    /**
     * Finds the first pair that passes the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @returns {?[ number, any ]}
     */
    findPair(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let i = 0; i < this.proxy.#l; i++) {
            if(!this.has(i)) continue;
            if(this.getDescriptor(i)?.enumerable === false) continue;
            let v = this.get(i);
            if(!!cb(v, i, [ v, i ], this.pairs, this) === true) return [ v, i ];
        };
        return undefined;
    };

    /**
     * Finds the first value that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {?any}
     */
    findValue(cb) {
        return super.find(cb);
    };

    /**
     * Finds the last element that passes the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @returns {?any}
     */
    findLast(cb) {
        let p = this.findLastPair(cb);
        return p ? p[1] : undefined;
    };

    /**
     * Finds the last entry that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {?any}
     */
    findLastEntry(cb) {
        return super.findLastEntry(cb);
    };

    /**
     * Finds the last index that passes the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @returns {?number}
     */
    findLastIndex(cb) {
        let p = this.findLastPair(cb);
        return p ? p[0] : undefined;
    };

    /**
     * Finds the last key that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {?any}
     */
    findLastKey(cb) {
        return super.findLastKey(cb);
    };

    /**
     * Finds the last pair that passes the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @returns {?[ number, any ]}
     */
    findLastPair(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let i = this.proxy.#l - 1; i >= 0; i--) {
            if(!this.has(i)) continue;
            if(this.getDescriptor(i)?.enumerable === false) continue;
            let v = this.get(i);
            if(!!cb(v, i, [ v, i ], this.pairs, this) === true) return [ v, i ];
        };
        return undefined;
    };

    /**
     * Finds the last value that passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {?any}
     */
    findLastValue(cb) {
        return super.findLast(cb);
    };

    /**
     * Returns the first values in this darray
     * @param {number} l Length
     * @returns {DArray}
     */
    first(l) {
        if(isNaN(l) && l !== undefined) throw new TypeError("Argument is not a number-like value");
        let il = l === undefined ? 1 : this.getIndex(l);
        if(il === undefined) il = Math.min(Math.max(parseInt(l), 0), this.proxy.#l);
        return this.slice(0, il);
    };

    /**
     * Gets the flags set in this darray
     * @readonly
     * @returns {{
     *     locked: boolean
     *     useStrict: boolean
     * }}
     */
    get flags() {
        return super.flags;
    };

    /**
     * Loops through each enumerable element
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @returns {boolean}
     */
    forEach(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let i = 0; i < this.proxy.#l; i++) {
            if(!this.has(i)) continue;
            if(this.getDescriptor(i)?.enumerable === false) continue;
            let v = this.get(i);
            cb(v, i, [ v, i ], this.pairs, this);
        };
        return true;
    };

    /**
     * Loops through each enumerable value
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {boolean}
     */
    forEachValue(cb) {
        return super.forEach(cb);
    };

    /**
     * Creates a new darray from an existing array
     * @static
     * @param {any[]} arr Array
     * @param {boolean} s Whether or not to use strict
     * @returns {DArray}
     */
    static from(arr, s) {
        if(!Array.isArray(arr)) throw new TypeError("Argument is not an array");
        return DArray.from({ ...arr }, arr.length, s);
    };

    /**
     * Creates a new darray from an existing object
     * @static
     * @param {object} obj Object
     * @param {number} l Length of darray
     * @param {boolean} s Whether or not to use strict
     * @returns {DArray}
     */
    static fromObject(obj, l, s) {
        if(typeof obj !== "object") throw new TypeError("Argument is not an object");
        let darr = new DArray(l, s);
        let ds = Object.getOwnPropertyDescriptors(obj);
        for(let k in ds) darr.setDescriptor(k, ds[k]);
        return darr;
    };

    /**
     * Gets a value from this darray
     * @param {any} k Key
     * @returns {?any}
     */
    get(k) {
        return super.get(this.inRange(k) ? `${k}` : k);
    };

    /**
     * Gets a descriptor from this darray
     * @param {any} k Key
     * @returns {?object}
     */
    getDescriptor(k) {
        return super.getDescriptor(this.inRange(k) ? `${k}` : k);
    };

     /**
     * Gets all descriptors from this darray
     * @returns {[ any, object ][]}
     */
    getDescriptors() {
        return super.getDescriptors();
    };

    /**
     * Gets a element from this darray
     * @param {number} k Key
     * @returns {?any}
     */
    getElement(k) {
        let p = this.getPair(k);
        if(!p) return undefined;
        return p[1];
    };

    /**
     * Gets a key from this darray
     * @param {number} k Key
     * @returns {?any}
     */
    getIndex(k) {
        let p = this.getPair(k);
        if(!p) return undefined;
        return p[0];
    };

    /**
     * Gets a pair from this darray
     * @param {number} k Key
     * @returns {?any}
     */
    getPair(k) {
        if(!isInt(k, this.proxy.#l - 1, -this.proxy.#l)) return undefined;
        let i = parseInt(k);
        if(i < 0) i = this.proxy.#l + i;
        if(i === undefined || !this.has(i)) return undefined;
        return [ i, this.get(i) ];
    };

    /**
     * Returns whether or not the key exists in this darray
     * @param {any} k Key
     * @returns {boolean}
     */
    has(k) {
        return super.has(this.inRange(k) ? `${k}` : k);
    };

    /**
     * Returns whether or not this darray includes the value
     * @param {any} v Value
     * @returns {boolean}
     */
    includes(v) {
        return this.some(_v => v === _v);
    };

    /**
     * Returns the indexes of this darray
     * @readonly
     * @returns {number[]}
     */
    get indexes() {
        return this.pairs.map(p => p[0]);
    };

    /**
     * Returns the first index of the value in this darray
     * @param {any} v Value
     * @returns {?number}
     */
    indexOf(v) {
        return this.findIndex(_v => v === _v);
    };

    /**
     * Whether or not the key is in range of this darray
     * @param {any} k Key
     * @returns {boolean}
     */
    inRange(k) {
        return isInt(k, this.proxy.#l - 1);
    };

    /**
     * Inserts new values into this darray
     * @param {number} s STarting index
     * @param  {...any} vs Values
     * @returns {boolean}
     */
    insert(s, ...vs) {
        if(this.flags.locked) {
            if(this.flags.useStrict) throw new Error("This instance is locked");
            return true;
        };
        if(this.getDescriptors().some(d => d[1]?.configurable === false)) {
            if(this.flags.useStrict) throw new Error("one or more keys are not configurable");
            return true;
        };
        if(isNaN(s)) throw new TypeError("Argument is not a number-like value");
        let is = parseInt(s);
        if(is < 0) is = this.getIndex(s) ?? 0;
        if(is < this.proxy.#l) for(let i = this.proxy.#l - 1; i >= is; i--) {
            if(!this.has(i)) this.delete(i + vs.length);
            else this.setDescriptor(i + vs.length, this.getDescriptor(i));
        };
        for(let i = 0; i < vs.length; i++) this.set(is + i, vs[i]);
        return true;
    };

    /**
     * Returns the true instance of this darray
     * @readonly
     * @returns {DArray}
     */
    get instance() {
        return this;
    };

    /**
     * Returns whether or not this darray is locked
     * @readonly
     * @returns {boolean}
     */
    get isLocked() {
        return super.isLocked;
    };

    /**
     * Returns whether or not this darray is using strict mode
     * @readonly
     * @returns {boolean}
     */
    get isStrict() {
        return super.isStrict;
    };

    /**
     * Concatenating all elements in this darray
     * @param {string} s String
     * @returns {string}
     */
    join(s) {
        return this.toArray().join(s);
    };

    /**
     * Returns the keys of this darray
     * @readonly
     * @returns {any[]}
     */
    get keys() {
        return super.keys;
    };

    /**
     * Returns the last values in this darray
     * @param {number} l Length
     * @returns {DArray}
     */
    last(l) {
        if(isNaN(l) && l !== undefined) throw new TypeError("Argument is not a number-like value");
        let il = l === undefined ? 1 : this.getIndex(l);
        if(il === undefined) il = Math.min(Math.max(parseInt(l), 0), this.proxy.#l);
        return this.slice(this.proxy.#l - il);
    };

    /**
     * Returns the last index of the value in this darray
     * @param {any} v Value
     * @returns {?number}
     */
    lastIndexOf(v) {
        return this.findLastIndex(_v => v === _v);
    };

    /**
     * Returns the length of this darray
     * @readonly
     * @returns {number}
     */
    get length() {
        return this.proxy.#l;
    };

    /**
     * Locks this darray and prevents further modifications
     * @returns {boolean}
     */
    lock() {
        return super.lock();
    };

    /**
     * Maps through each enumerable element
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @returns {DArray}
     */
    map(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let darr = new DArray(this.proxy.#l, this.useStrict);
        this.forEach((v, i, p, ps, ins) => {
            let d = this.getDescriptor(i);
            if("get" in d && "set" in d) dobj.setDescriptor(i, {
                get: () => cb(d.get(), i, p, ps, ins),
                set: () => d.set()
            });
            else darr.setDescriptor(i, {
                configurable: d.configurable,
                enumerable: d.enumerable,
                value: cb(v, i, p, ps, ins),
                writable: d.writable
            });
        });
        return darr;
    };

    /**
     * Maps through each enumerable value
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {DArray}
     */
    mapValues(cb) {
        return super.map(cb);
    };

    /**
     * Merges enumerable keys and values from one or more darrays to this darray
     * @param {...darray} darr DArrays
     * @returns {boolean}
     */
    merge(...darrs) {
        if(this.flags.locked) {
            if(this.flags.useStrict) throw new Error("This instance is locked");
            return true;
        };
        for(let darr of darrs) {
            if(!(darr instanceof DArray)) {
                if(darr === null || dobj === undefined) console;
                if(this.flags.useStrict) throw new TypeError("Argument is not an instance of DArray");
                continue;
            };
            if(Object.is(this, darr.instance)) {
                if(this.flags.useStrict) throw new TypeError("Cannot merge with itself");
                continue;
            };
            let ds = darr.getDescriptors();
            let l = this.proxy.#l;
            for(let d of ds) this.setDescriptor(this.inRange(d[0]) ? l + parseInt(d[0]) : d[0], d[1]);
        };
        return true;
    };

    /**
     * Merges and overwrites enumerable keys and values from one or more darrays to this darray
     * @param {...darray} darr DArrays
     * @returns {boolean}
     */
    mergeValues(...darr) {
        return super.merge(...darr);
    };

    /**
     * Returns the pairs of this darray
     * @readonly
     * @returns {[ number, any ][]}
     */
    get pairs() {
        return this.entries.filter(e => this.inRange(e[0]));
    };


    /**
     * Removes the last element from this darray
     * @param {number} l Length
     * @returns {boolean}
     */
    pop(l) {
        if(this.flags.locked) {
            if(this.flags.useStrict) throw new Error("This instance is locked");
            return true;
        };
        if(this.getDescriptors().some(d => d[1]?.configurable === false)) {
            if(this.flags.useStrict) throw new Error("one or more keys are not configurable");
            return true;
        };
        if(isNaN(l) && l !== undefined) throw new TypeError("Argument is not a number-like value");
        let il = l === undefined ? 1 : this.getIndex(l);
        if(il === undefined) il = Math.min(Math.max(parseInt(l), 0), this.proxy.#l);
        return this.remove(this.proxy.#l - il, this.proxy.#l);
    };

    /**
     * Returns the true proxy of this darray
     * @readonly
     * @returns {Proxy}
     */
    get proxy() {
        return super.proxy;
    };

    /**
     * Adds new values at the end of this darray
     * @param  {...any} vs Values
     * @returns {boolean}
     */
    push(...vs) {
        if(this.flags.locked) {
            if(this.flags.useStrict) throw new Error("This instance is locked");
            return true;
        };
        if(this.getDescriptors().some(d => d[1]?.configurable === false)) {
            if(this.flags.useStrict) throw new Error("one or more keys are not configurable");
            return true;
        };
        let l = this.proxy.#l;
        for(let v of vs) this.set(l++, v);
        return true;
    };

    /**
     * Reduces this darray from left to right and returns a single value
     * @param {function(any, any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @param {any} iv Initial value
     * @returns {any}
     */
    reduce(cb, iv) {
        if(typeof cb !== "function") throw new Error("Argument is not a function");
        let a = iv === undefined ? this.get(0) : iv;
        for(let i = iv === undefined ? 1 : 0; i < this.proxy.#l; i++) {
            if(!this.has(i)) continue;
            let v = this.get(i);
            a = cb(a, v, i, [ i, v ], this.pairs, this);
        };
        return a;
    };
    
    /**
     * Reduces this darray from right to left and returns a single value
     * @param {function(any, any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @param {any} iv Initial value
     * @returns {any}
     */
    reduceLast(cb, iv) {
        if(typeof cb !== "function") throw new Error("Argument is not a function");
        let a = iv === undefined ? this.get(this.proxy.#l - 1) : iv;
        for(let i = iv === undefined ? this.proxy.#l - 2 : this.proxy.#l - 1; i >= 0; i--) {
            if(!this.has(i)) continue;
            let v = this.get(i);
            a = cb(a, v, i, [ i, v ], this.pairs, this);
        };
        return a;
    };

    /**
     * Removes elements from this darray
     * @param {number} s Starting index
     * @param {?number} e Ending index
     * @returns {boolean}
     */
    remove(s, e) {
        if(this.flags.locked) {
            if(this.flags.useStrict) throw new Error("This instance is locked");
            return true;
        };
        if(this.getDescriptors().some(d => d[1]?.configurable === false)) {
            if(this.flags.useStrict) throw new Error("one or more keys are not configurable");
            return true;
        };
        if(isNaN(s)) throw new TypeError("Argument is not a number-like value");
        let is = this.getIndex(s);
        if(is === undefined) is = Math.min(Math.max(parseInt(s), 0), this.proxy.#l);
        if(isNaN(e) && e !== undefined) throw new TypeError("Argument is not a number-like value");
        let ie = e === undefined ? is + 1 : this.getIndex(e);
        if(ie === undefined) ie = Math.min(Math.max(parseInt(e), is), this.proxy.#l);
        else if(ie < is) ie = is;
        console.log(is, ie);
        for(let i = is; i < ie; i++) this.delete(i);
        for(let i = ie; i <= this.proxy.#l; i++) {
            if(!this.has(i)) this.delete(i - ie + is);
            else this.setDescriptor(i - ie + is, this.getDescriptor(i));
            if(is !== ie) this.delete(i);
        };
        this.proxy.#l = Math.max(this.proxy.#l - ie + is, 0);
        return true;
    };
    
    /**
     * Reverses this darray
     * @returns {DArray}
     */
    reverse() {
        let darr = new DArray(this.proxy.#l, this.flags.useStrict);
        let ds = this.getDescriptors();
        for(let d of ds) darr.setDescriptor(this.inRange(d[0]) ? this.proxy.#l - parseInt(d[0]) - 1 : d[0], d[1]);
        return darr;
    };

    /**
     * Sets a value with the associating key to this darray
     * @param {any} k Key
     * @param {any} v Value
     * @returns {boolean}
     */
    set(k, v) {
        if(isNaN(k) || !isInt(k)) return super.set(k, v);
        if(!this.inRange(k)) this.proxy.#l = parseInt(k) + 1;
        return super.set(`${k}`, v);
    };

    /**
     * Sets a descriptor with the associating key to this darray
     * @param {any} k Key
     * @param {object} d Descriptor
     * @returns {boolean}
     */
    setDescriptor(k, d) {
        if(isNaN(k) || !isInt(k)) return super.setDescriptor(k, d);
        if(!this.inRange(k)) this.proxy.#l = parseInt(k) + 1;
        return super.setDescriptor(`${k}`, d);
    };

    /**
     * Sets multiple descriptors to this darray
     * @param {[ any, object ][]} ds Descriptors
     * @returns {boolean}
     */
    setDescriptors(es) {
        if(!areEntries(es)) throw new Error("Argument are not entries");
        for(let e of es) this.setDescriptor(e[0], e[1]);
        return true;
    };

    /**
     * Sets a readonly value with the associating key to this darray
     * @param {any} k Key
     * @param {any} v Value
     * @returns {boolean}
     */
    setReadOnly(k, v) {
        return super.setReadOnly(this.inRange(k) ? `${k}` : k, v);
    };

    /**
     * Removes the first element from this darray
     * @param {number} l Length
     * @returns {boolean}
     */
    shift(l) {
        if(this.flags.locked) {
            if(this.flags.useStrict) throw new Error("This isntance is locked");
            return true;
        };
        if(this.getDescriptors().some(d => d[1]?.configurable === false)) {
            if(this.flags.useStrict) throw new Error("one or more keys are not configurable");
            return true;
        };
        if(isNaN(l) && l !== undefined) throw new TypeError("Argument is not a number-like value");
        let il = l === undefined ? 1 : this.getIndex(l);
        if(il === undefined) il = Math.min(Math.max(parseInt(l), 0), this.proxy.#l);
        return this.remove(0, il);
    };

    /**
     * Returns the size of this darray
     * @readonly
     * @returns {number}
     */
    get size() {
        return super.size;
    };

    /**
     * Slices and returns a chunk of this darray
     * @param {number} s Starting index
     * @param {?number} e Ending index
     * @returns {DArray}
     */
    slice(s, e) {
        if(isNaN(s)) throw new TypeError("Argument is not a number-like value");
        let is = this.getIndex(s);
        if(is === undefined) is = Math.min(Math.max(parseInt(s), 0), this.proxy.#l);
        if(isNaN(e) && e !== undefined) throw new TypeError("Argument is not a number-like value");
        let ie = e === undefined ? this.proxy.#l : this.getIndex(e);
        if(ie === undefined) ie = Math.min(Math.max(parseInt(e), is), this.proxy.#l);
        else if(ie < is) ie = is;
        let darr = new DArray(ie - is, this.flags.useStrict);
        for(let i = is; i < ie; i++) if(this.has(i)) darr.setDescriptor(i - is, this.getDescriptor(i));
        return darr;
    };

    /**
     * Returns if a element passes the callback
     * @param {function(any, number, [ number, any ], [ number, any ][], DArray)} cb Callback
     * @returns {boolean}
     */
    some(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let i = 0; i < this.proxy.#l; i++) {
            if(!this.has(i)) continue;
            if(this.getDescriptor(i)?.enumerable === false) continue;
            let v = this.get(i);
            if(!!cb(v, i, [ v, i ], this.pairs, this) === true) return true;
        };
        return false;
    };

    /**
     * Returns if a value passes the callback
     * @param {function(any, any, [ any, any ], [ any, any ][], DArray)} cb Callback
     * @returns {boolean}
     */
    someValue(cb) {
        return super.some(cb);
    };

    /**
     * Sorts this darray
     * @param {function(any, any)} cb Callback
     * @returns {DArray}
     */
    sort(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let arr = new Array(this.proxy.#l);
        for(let i = 0; i < this.proxy.#l; i++) {
            if(!this.has(i)) continue;
            if(this.getDescriptor(i)?.enumerable === false) continue;
            arr[i] = { d: this.getDescriptor(i), v: this.get(i) };
        };
        let darr = new DArray(this.proxy.#l, this.flags.useStrict);
        let s = arr.sort((a, b) => cb(a.v, b.v));
        for(let i in s) darr.setDescriptor(i, s[i].d);
        for(let d of this.getDescriptors().filter(d => !this.inRange(d[0]))) darr.setDescriptor(d[0], d[1]);
        return darr;
    };

    /**
     * Splices and adds new elements to this darray
     * @param {number} s Starting index
     * @param {number} l Length of deletion
     * @param  {...any} vs Values
     * @returns 
     */
    splice(s, l, ...vs) {
        if(isNaN(s)) throw new TypeError("Argument is not a number-like value");
        let is = this.getIndex(s);
        if(is === undefined) is = Math.min(Math.max(parseInt(s), 0), this.proxy.#l);
        if(isNaN(l)) throw new TypeError("Argument is not a number-like value");
        this.remove(is, is + l);
        this.insert(is, ...vs);
        return true;
    };

    /**
     * Returns this darray as a JavaScript array
     * @returns {any[]}
     */
    toArray() {
        let arr = new Array(this.proxy.#l);
        Object.defineProperties(arr, Object.fromEntries(this.getDescriptors()));
        return arr;
    };

    /**
     * Returns this darray as a JavaScript object
     * @returns {object}
     */
    toObject() {
        return super.toObject();
    };

    /**
     * Returns this darray as a JavaScript string
     * @returns {string}
     */
    toString() {
        return JSON.stringify(this.toArray());  
    };

    /**
     * Enables strict mode in this darray
     * @returns {boolean}
     */
    useStrict() {
        return super.useStrict();
    };

    /**
     * Adds new values at the front of this darray
     * @param {...any} vs Values
     * @returns {boolean}
     */
    unshift(...vs) {
        if(this.flags.locked) {
            if(this.flags.useStrict) throw new Error("This instance is locked");
            return true;
        };
        if(this.getDescriptors().some(d => d[1]?.configurable === false)) {
            if(this.flags.useStrict) throw new Error("one or more keys are not configurable");
            return true;
        };
        for(let i = this.proxy.#l - 1; i >= 0; i--) {
            if(!this.has(i)) this.delete(i + vs.length);
            else this.setDescriptor(i + vs.length, this.getDescriptor(i));
        };
        for(let i = 0; i < vs.length; i++) this.set(i, vs[i]);
        return true;
    };

    /**
     * Returns the values of this darray
     * @readonly
     * @returns {any[]}
     */
    get values() {
        return super.values;
    };

    /**
     * Returns this darray as a JavaScript array
     * @returns {any[]}
     */
    valueOf() {
        return this.toArray();
    };

    *[Symbol.iterator]() {
        for(let i = 0; i < this.proxy.#l; i++) {
            if(this.getDescriptor(i)?.enumerable === false) yield undefined;
            yield this.get(i);
        };
    };
};

// Exports
module.exports = DArray;