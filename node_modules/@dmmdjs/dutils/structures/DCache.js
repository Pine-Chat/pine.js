"use strict";

// Imports
const Events = require("events");

/**
 * Scalable extension of caching system with native object method support
 * @extends Events
 */
class DCache extends Events {
    #header = {
        locked: false
    };
    #memory = new Map();
    #meta;
    #proxy;

    /**
     * Creates a new dcache
     * @returns {Proxy}
     */
    constructor() {
        super();
        this.#meta = { header: this.header, body: this.body, memory: this.memory };
        this.#proxy = new Proxy(this.#meta, {
            deleteProperty: (t, k) => t.body.delete(k),
            get: (t, k) => {
                if(k in t.body.constructor.prototype) {
                    let p = t.body[k];
                    return typeof p === "function" ? p.bind(t.body) : p;
                };
                return t.body.get(k);
            },
            getPrototypeOf: t => t.body,
            has: (t, k) => t.body.has(k),
            isExtensible: t => t.header.locked,
            ownKeys: t => t.body.keys,
            preventExtensions: t => t.body.lock(),
            set: (t, k, v) => t.body.set(k, v),
            setPrototypeOf: () => {
                throw new TypeError("Please do not modify the prototype of DCache");
            }
        });
        this.#meta.proxy = this.#proxy;
        return this.#proxy;
    };

    /**
     * Returns the body of this dcache
     * @readonly
     * @returns {DCache}
     */
    get body() {
        return this;
    };

    /**
     * Clears this dcache
     * @returns {boolean}
     */
    clear() {
        if(this.#header.locked) throw new Error("Cannot modify a locked dcache");
        this.#memory.clear();
        super.emit("clear");
        return true;
    };

    /**
     * Clones this dcache
     * @param {boolean} d Whether or not to deep clone
     * @returns {DCache} 
     */
    clone(d) {
        let clone = new DCache();
        for(let [ k, v ] of this.#memory.entries()) clone.set(k, d ? JSON.parse(JSON.stringify(v)) : v);
        return clone;
    };

    /**
     * Decreases a value in this dcache
     * @param {any} k Key
     * @param {number} v Decrement
     * @returns {boolean}
     */
    decrease(k, v = 1) {
        if(this.#header.locked) throw new Error("Cannot modify a locked dcache");
        if(isNaN(v)) throw new TypeError("Argument is not a number");
        if(this.has(k) && isNaN(this.get(k))) throw new TypeError("Cannot increment a non-number value");
        this.set(k, +(this.has(k) ? this.get(k) : 0) - v);
        super.emit("decrease");
        return true;
    };

    /**
     * Deletes a key from this dcache
     * @param {any} k Key
     * @returns {boolean}
     */
    delete(k) {
        if(this.#header.locked) throw new Error("Cannot modify a locked dcache");
        if(!this.has(k)) return true;
        let v = this.get(k);
        this.#memory.delete(k);
        super.emit("delete", k, v);
        return true;
    };

    /**
     * Sets a default value if the key doesn't exist in this dcache
     * @param {any} k Key
     * @param {any} v Value
     * @returns {boolean}
     */
    ensure(k, v) {
        if(this.#header.locked) throw new Error("Cannot modify a locked dcache");
        if(this.has(k)) return true;
        this.set(k, v);
        super.emit("ensure", k, v);
        return true;
    };

    /**
     * Returns all entries of this dcache
     * @readonly
     * @returns {[ any, any ][]}
     */
    get entries() {
        return Array.from(this.#memory.entries());
    };

    /**
     * Returns if all entries in this dcache passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {boolean}
     */
    every(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let [ k, v ] of this.#memory.entries()) if(!cb(v, k, this)) return false;
        return true;
    };

    /**
     * Filters all values in this dcache that passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {any[]}
     */
    filter(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let r = [];
        for(let [ k, v ] of this.#memory.entries()) if(cb(v, k, this)) r.push(v);
        return r;
    };

    /**
     * Filters all entries in this dcache that passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {[ any, any ][]}
     */
    filterEntries(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let r = [];
        for(let [ k, v ] of this.#memory.entries()) if(cb(v, k, this)) r.push([ k, v ]);
        return r;
    };

    /**
     * Filters all keys in this dcache that passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {any[]}
     */
    filterKeys(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let r = [];
        for(let [ k, v ] of this.#memory.entries()) if(cb(v, k, this)) r.push(k);
        return r;
    };

    /**
     * Finds the first value in this dcache that passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {any}
     */
    find(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let [ k, v ] of this.#memory.entries()) if(cb(v, k, this)) return v;
        return null;
    };

    /**
     * Finds the first entry in this dcache that passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {[ any, any ]}
     */
    findEntry(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let [ k, v ] of this.#memory.entries()) if(cb(v, k, this)) return [ k, v ];
        return null;
    };

    /**
     * Finds the first key in this dcache that passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {any[]}
     */
    findKey(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let [ k, v ] of this.#memory.entries()) if(cb(v, k, this)) return k;
        return null;
    };

    /**
     * Finds the last value in this dcache that passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {any}
     */
    findLast(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let e = this.#memory.entries();
        for(let i = e.length - 1; i >= 0; i--) {
            let [ k, v ] = e[i];
            if(cb(v, k, this)) return v;
        };
        return null;
    };

    /**
     * Finds the last entry in this dcache that passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {[ any, any ]}
     */
    findLastEntry(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let e = this.#memory.entries();
        for(let i = e.length - 1; i >= 0; i--) {
            let [ k, v ] = e[i];
            if(cb(v, k, this)) return [ k, v ];
        };
        return null;
    };
    
    /**
     * Finds the last key in this dcache that passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {any[]}
     */
    findLastKey(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let e = this.#memory.entries();
        for(let i = e.length - 1; i >= 0; i--) {
            let [ k, v ] = e[i];
            if(cb(v, k, this)) return k;
        };
        return null;
    };

    /**
     * Loops through this dcache from the first to the last
     * @param {function(any, any, DCache)} cb Callback
     * @returns {boolean}
     */
    forEach(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let [ k, v ] of this.#memory.entries()) cb(v, k, this);
        return true;
    };

    /**
     * Loops through this dcache from the last to the first
     * @param {function(any, any, DCache)} cb Callback
     * @returns {boolean}
     */
    forEachLast(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let e = this.#memory.entries();
        for(let i = e.length - 1; i >= 0; i--) {
            let [ k, v ] = e[i];
            cb(v, k, this);
        };
        return null;
    };

    /**
     * Returns the value from a key in this dcache
     * @param {any} k Key
     * @returns {any}
     */
    get(k) {
        return this.#memory.get(k);
    };

    /**
     * Returns if the key exists in this dcache
     * @param {any} k Key
     * @returns {boolean}
     */
    has(k) {
        return this.#memory.has(k);
    };

    /**
     * Returns the header of this dcache
     * @readonly
     * @returns {object}
     */
    get header() {
        return JSON.parse(JSON.stringify(this.#header));
    };

    /**
     * Increases a value in this dcache
     * @param {any} k Key
     * @param {number} v Increment
     * @returns {boolean}
     */
    increase(k, v = 1) {
        if(this.#header.locked) throw new Error("Cannot modify a locked dcache");
        if(isNaN(v)) throw new TypeError("Argument is not a number");
        if(this.has(k) && isNaN(this.get(k))) throw new TypeError("Cannot increment a non-number value");
        this.set(k, +(this.has(k) ? this.get(k) : 0) + v);
        super.emit("increase");
        return true;
    };

    /**
     * Returns whether or not this dcache is locked
     * @readonly
     * @returns {boolean}
     */
    get isLocked() {
        return this.#header.locked;
    };

    /**
     * Returns all keys of this dcache
     * @readonly
     * @returns {any[]}
     */
    get keys() {
        return Array.from(this.#memory.keys());
    };

    /**
     * Locks this dcache
     * @returns {boolean}
     */
    lock() {
        if(this.#header.locked) return true;
        this.#header.locked = true;
        super.emit("lock");
        return true;
    };

    /**
     * Maps through this dcache
     * @param {function(any, any, DCache)} cb Callback
     * @param {boolean} m Whether or not to merge (instead of making a clone)
     * @returns {boolean|DCache}
     */
    map(cb, m) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        let t = m ? this : new DCache();
        for(let [ k, v ] of this.#memory.entries()) t.set(k, cb(v, k, this));
        return m ? true : t;
    };

    /**
     * Returns the memory of this dcache
     * @readonly
     * @returns {Map}
     */
    get memory() {
        return this.#memory;
    };

    /**
     * Merges other dcaches with this dcache
     * @param {function(any, any, DCache)} cb Callback
     * @param {boolean} m Whether or not to merge (instead of making a clone)
     * @returns {boolean|DCache}
     */
    merge(dcaches, m) {
        if(this.#header.locked) throw new Error("Cannot modify a locked dcache");
        if(!Array.isArray(dcaches)) throw new TypeError("Argument is not an array");
        let t = m ? this : new DCache();
        for(let dcache of m ? dcaches : [ this, ...dcaches ]) {
            if(!(dcache instanceof DCache)) continue;
            for(let entry of dcache.entries) t.set(entry[0], entry[1]);
        };
        if(m) super.emit("merge", ...dcaches);
        return m ? true : t;
    };

    /**
     * Returns the meta of this dcache
     * @readonly
     * @returns {object}
     */
    get meta() {
        return {
            body: this.body,
            header: this.header,
            memory: this.memory,
            proxy: this.proxy
        };
    };

    /**
     * Returns the proxy of this dcache
     * @readonly
     * @returns {Proxy}
     */
    get proxy() {
        return this.#proxy;
    };

    /**
     * Reverses this dcache
     * @param {boolean} m Whether or not to merge (instead of making a clone)
     * @returns {boolean|DCache}
     */
    reverse(m) {
        let e = this.entries, t = m ? this : new DCache();
        t.clear();
        for(let i = e.length - 1; i >= 0; i--) {
            let [ k, v ] = e[i];
            t.set(k, v);
        };
        if(m) super.emit("reverse", e);
        return m ? true : t;
    };

    /**
     * Sets a value to this key in this dcache
     * @param {any} k Key 
     * @param {any} v Value
     * @returns {boolean}
     */
    set(k, v) {
        if(this.#header.locked) throw new Error("Cannot modify a locked dcache");
        this.#memory.set(k, v);
        super.emit("set", k, v);
        return true;
    };

    /**
     * Returns the size of this dcache
     * @readonly
     * @returns {number}
     */
    get size() {
        return this.#memory.size;
    };

    /**
     * Returns if at least one entry in this dcache passed the predicate
     * @param {function(any, any, DCache)} cb Callback
     * @returns {boolean}
     */
    some(cb) {
        if(typeof cb !== "function") throw new TypeError("Argument is not a function");
        for(let [ k, v ] of this.#memory.entries()) if(cb(v, k, this)) return true;
        return false;
    };

    /**
     * Converts this dcache into a JSON
     * @returns {object}
     */
    toObject() {
        return Object.fromEntries(this.#memory.entries());
    };

    /**
     * Converts this dcache into a string
     * @returns {string}
     */
    toString() {
        return JSON.stringify(Object.fromEntries(this.#memory.entries()));
    };

    /**
     * Returns all keys of this dcache
     * @readonly
     * @returns {any[]}
     */
    get values() {
        return Array.from(this.#memory.values());
    };

    /**
     * Returns the value of this dcache
     * @returns {DCache}
     */
    valueOf() {
        return this;
    };

    *[Symbol.iterator]() {
        for(let v of this.#memory.values()) yield v;
    };
};

// Exports
module.exports = DCache;